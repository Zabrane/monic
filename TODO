* streaming - DONE
* checksums - DONE
* cookies - DONE
* reader concurrency
* preallocation
* deletion
* compaction

== Preallocation ==

* Extend to prealloc size on creation using fallocate/2
* Eof tracked in header.
* start at Eof and skip over all entries to real Eof, write down new Eof if different.

== caching ==

* make metadata files.
* keep ets of metadata.
* {Group, Key, Cookie} -> {File, Offset}

== API ==

Lookup by key as location will change on compaction.

=== READ ===

read(Group, Key, Cookie, Fun) -> {ok, Bin} | {error, Reason}
read(Group, Key, Cookie, Ranges, Fun) -> ok | {error, Reason}

Fun is called with;

{ok, Bin} - a chunk of data.
{checksum, verified|failed} - checksum validity.
eof - end of data.
{error, Reason} - error while reading.

=== WRITE ===

write(Group, Key, Fun) -> {ok, Cookie} | {error, Reason}

Fun is called with one argument, the maximum number of bytes to return in a chunk.

The fun may evaluate to any of the following;

{ok, Bin} - a chunk of data.
eof - end of data.
{error, Reason} - error while reading.

=== MISC ===

delete(Group, Key, Cookie) -> ok | {error, Reason}
compact(Group) -> ok
